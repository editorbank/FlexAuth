## Часто задаваемые вопросы

> Какого размера может быть размер ключа?

Размер ключевой информации может быть практически любым. Например, по ней можно считать хеш-сумму 
и уже хеш-сумму использовать в качестве "ключа". Главное: такой же алгоритм нужно будет использовать при
заполнении списка доступа.

> В чём может хранится список доступа? 

В самом простом случае списком доступа может быть файловая система с набором пустых файлов.
Для промышленных масштабов это может быть децентрализованная, отказоустойчивая и надёжная база данных "ключ-значение".
А если правовая информация каким-то образом алгоритмизируется, роль списка доступа может исполнять любое другое веб-приложение,  
отвечающее на запросы ключа HTTP-статусами:
 "200" - в случае наличия доступа и 
 "404" - при его отсутствии.   

> Прокси сервер, насколько это тяжеловесное решение?

Функцию подобного прокси-сервера может выполнять и часть кода клиентского приложения, которая встраивается 
в приложение в виде библиотеки. Отдельно разрабатываемые прокси-сервера обычно имеют более высокий уровень 
проработки защиты от сетевых атак и оптимизации трафика чем библиотеки, предназначенные для встраивания. 
С точки зрения стабильности работы системы в целом отдельный процесс прокси-сервера может "упасть", но работа 
основного приложения нарушена не будет. Это особенно важно для приложений, хранящих данные в оперативной памяти.
Например, при потере связи с прокси-сервером оно может корректно сохранить накопленные данные на диск и 
корректно завершить работу.    

Если судить по занимаемому месту на диске, например, мы пишем ПО на Java:
 * Размер файлов виртуальной машины Java 1.8: 360 МБ.    
 * Размер файлов библиотек для создания простого Spring boot приложения: 10 МБ.
 * Размер файла nginx: 3.6 МБ.
В этом случае объём файлов прокси-сервера 1% от объёма основного ПО.

> Насколько эффективно делать ещё один авторизационный подзапрос на каждый запрос?

Размер подзапроса достаточно мал, в нём передается практически только ключ, в ответе нужен только HTTP-статус.
Такие запросы не содержат переменных частей и поэтому хорошо кэшируются. Если в качестве интерфейса с кэшем
будут использованы именованные каналы, это будет соизмеримо со скоростью доступа в память.  

> Как использовать такую авторизацию в SOAP протоколе, в нём все типы запросов POST с неизменным URL

Протокол SOAP - самый неудобный формат обмена для авторизации такого типа. Авторизация возможна только на уровне
"Субъект имеет доступ или нет", без детализации по запросам, так как вся информация о действии и объекте расположена 
внутри тела сообщения. Для этого типа авторизации предпочтение следует отдавать 
протоколам, у которых вся информация, участвующая в формировании ключа, находится в заголовке HTTP-сообщения, 
например, в таких как REST.         

> Насколько такой подход перспективен?

Любая часть системы может быть заменена, не затрагивая другие,
или расширена необходимым количеством экземпляров.
В системе нет привязки к определенным ОС или особенностям конкретного ПО. 
Всегда можно заменить одну компоненту на другую, более современную, 
поменять алгоритмы генерации ключей, перейти на более защищенный протокол обмена.
Это больше концепция, чем готовая система.        
