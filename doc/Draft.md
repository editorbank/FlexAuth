 
## Тезисы/дополнительные возможности
* Управлять кешем прав может одновременно несколько приложений
* Динамически - при первом запросе от пользователя, если таблицы его прав нет в кеше они туда загружаются.
* Ограничение времени сеанса пользователя
* Автопродление времени работы при выполнении критичных операций   
* снижение нагрузки на приложения за счет частичного кеширования контента
* развязка приложений через кеш 
* многие БД "ключ-значение" имеют встроенные механизмы времени хранения данных
* точки втстраивания аудита критичных действий для Legacy-приложений
* Вынос средств защиты из приложения - это возможность поддержки их всегда в актуальном состоянии. 
Не требует доработки приложений. Разделение зон ответственности между людьми при настройке серверов. 
+ Обработка сообщений об ошибках связи в формате передачи данных приложения. 
(например, кода приложение от сервера ожидает ответ в формате JSON, 
а ему приходит сообщение об ошибке тоже в формате JSON, а не HTML. 
Это упрощает и ускоряет разработку.     

---
 
> Как я понимаю, технический мониторинг перестает развиваться и поэтому решения, которые обеспечивают его развития сейчас не нужны.

Согласен, дальнейшее развитие технического мониторинга нецелесообразно.

> Сейчас мы разрабатываем на ЕФС, который имеет несколько сервисов, обеспечивающих безопасность:
> * Судир – аутентификация
> * Стартовый менеджер (https://sbtatlas.sigma.sbrf.ru/wiki/pages/viewpage.action?pageId=604276099) – ограничение прав на клиенте
> * ФП Сервис авторизации (https://sbtatlas.sigma.sbrf.ru/wiki/pages/viewpage.action?pageId=604506246) – ограничение прав на прикладном уровне
> * Внутренний шлюз (https://sbtatlas.sigma.sbrf.ru/wiki/pages/viewpage.action?pageId=604276103) – аутентификация потребителей при вызове сервиса
>
> P.s. на данном решение успешно выведен в пром и успешно там работает Сбол Про.
> Если необходима экспертная консультация по какому-либо из сервисов, то можно связаться с разработчиками сервисов (раздел «Участники команды»).

* СУДИР - при гибкой авторизации остается и является её неотъемлемой частью. 
* Стартовый менеджер - предназначен только для отображения ссылок на бакэнд приложения.
Это не является какой, либо защитой, злоумышленик может узнать ссылку на бакэнд приложения и выполнить запрос к нему.
* Внутренний шлюз - Выполняет функции балансировки, не используется для ограничения прав внутри приложения. но его можно задействовать в схеме гибкой авторизации.
* ФП Сервис авторизации - имеет библиотеки которые встраиваются в разрабатываемое приложение.

Рассмотрим ФП «Сервис авторизации» в ЕФС.
Ниже выдержки из его документации:

Подключение Сервиса авторизации и API
~~~
<dependency>
    <groupId>ru.sbrf.ufs.platform</groupId>
    <artifactId>ufs-platform-security</artifactId>
    <version><последняя актуальная опубликованная версия для релиза, в которым планируется выход вашего функционала (в Синтетическом приложении)></version>
</dependency>
<dependency>
    <groupId>ru.sbrf.ufs.platform</groupId>
    <artifactId>ufs-platform-security-api</artifactId>
    <version><последняя актуальная опубликованная версия для релиза, в которым планируется выход вашего функционала (в Синтетическом приложении)></version>
</dependency>
~~~

* Подключаем библиотеку. И сразу впадаем в зависимость от последней актуальной опубликованной версии для релиза, в которым планируется выход нашего функционала.
То есть не успели в релиз или захотели внедриться раньше => перекомпиляция, перетестирование ….
```
Закрытие REST авторизацией:
Для того, чтобы закрыть REST авторизацией используйте аннотацию.
ИСПОЛЬЗОВАНИЕ АННОТАЦИИ
В релизе R18.3 в аннотации к REST допускается использование только 1 привилегии.
Начиная с релиза R18.5 в аннотации к REST допускается использование >1 привилегии.
Аннотация работает при следующих условиях:
    1. Аннотация добавлена к REST.
    2. В spring дескрипторе добавлены используемые классы.
    Пример включения endpoint в spring дескриптор

<ctx:component-scan base-package="ru.sbrf.ufs.yourservice.admin.imports.endpoint"/>
/** base-package - имя пакета, в котором находится ваш endpoint
* На классе endpoint-а должна быть аннотация @Component в данной конфигурации
*/

    3. Аннотация работает только вместе с сессией пользователя.
Образец (приведен  для примера ,  не копипастить , пожалуйста):
@Secured({"ManageExample.ManageExampleGroups.ViewListOfUserSamples", "ManageExapmle.ManageExampleGroups.ViewListOfUserSamples"})
```
* Проверки прав всё равно происходят в коде приложения, сообщение которое может быть большим, уже влетело в него и заняло память …
* Мы получаем некоторую промежуточную сущность в виде «привилегии» которую нам придется связывать (мапить) с ресурсом (REST-методом). Информация что с чем смаплено в коде, «select …» по нему не сделаешь, смотреть только глазками …
* Привязка к сессии == прощай «Round robbing», прощай балансировка, привет Тразактоподобие ….

 
~~~
Пример использования API
//Получить список привилегий текущего пользователя
Set<String> res =  authorizationService.getPermissions("SUPPORT");

//проверить наличие определенной привилегии у пользователя
boolean value = authorizationService.checkPermission("ManagePermissions.ManageOperations.AdminOperationPanel");

//Проверить наличие определенных групп у пользователя
boolean val = authorizationService.checkGroup("Группа администраторов");

//Получить список всех админских групп
Set<Group> adminGroups = authorizationService.getGroups(CategoryCode.ADMIN);

//Получить список всех админских привилегий
Set<String> adminPermissions = authorizationService.getPermissions(CategoryCode.ADMIN);

//Получить список всех клиентских групп
Set<Group> clientGroups = authorizationService.getGroups(CategoryCode.CLIENT_UL);

//Получить список всех клиентских привилегий
Set<String> clientPermissions = authorizationService.getPermissions(CategoryCode.CLIENT_UL);
~~~
* Широкие возможности для хардкода! Продолжаем «пропитывать» код проверками …

Резюмирую, развивать технический мониторинг по схеме предложенной Максимом нет смысла, ровно такая же будет в ЕФС.
 
---

Насчёт Eureka, заключение автора:
"Итак, мы разобрались со стандартной настройкой Eureka-сервера и клиентов и получили возможность динамически получать информацию о сервисах в нашей инфраструктуре. Конечно, за это пришлось заплатить усложнённой конфигурацией и необходимостью поддерживать ещё один сервис. И так как жизнеспособность его критична для функционирования всей системы, желательно развернуть несколько его экземпляров. " в статье https://springgears.com/eureka-service-discovery-intro/  звучит не очень убедительно.
А разве OpenShift не для этого-же? Разве не для динамического управления сервисами?

"zuul написан на java у нас появляется возможность перейти сразу на istio" - Если учесть что Istio написан на Go, связь особо не заметна. И кстати, Envoy - прокси-сервер который используется в Istio для "закрытия" приложений (в так называемых Sidecar-ах) единственный написан на C++, как и Nginx. Это сделано для "предсказуемого выделения памяти".
Что характерно и для IBM Security Access Manager, где практически всё ПО написано на Java, но WebSEAL (это их прокси-сервер) так же С/С++.
В каждом ПО есть особо критичные участки, которые должны быть очень тщательно проработаны. 

---

Коллеги, касательно варианта с zuul.
В процессе продумывания архитектуры пришел к тому, что консолидировать логику авторизации в одном месте неправильно. Все-таки это специфичная для конкретного приложения бизнес-логика и вынести ее полностью во вне не получится. Да, можно сделать общие сервисы – мы сделали МУП, но полностью исключить фукционал авторизации из ФПшек неправильно – определить, что проверять и проверить это вызвав МУП – их работа. На первый взгляд, удобно это все переложить на zuul, но со временем эти проверки превратятся в громадную неуправляемую массу. Поэтому вашему вниманию предлагается другая схема:

Здесь zuul занимается проксированием вызовов по таблице правил. ФПшки вызывают МУП для проверки прав сами. В принципе здесь можно на nginx все сделать, но т.к. zuul написан на java у нас появляется возможность перейти сразу на istio, а в перспективе еще подключить механизм service discovery (Eureka).
Вместе с istio, по моим оценкам, тут месяца на 2-3 работ.

---

Вопрос: сейчас у нас авторизация устроена через представление COMPUTEL_ALLUSERS Транзакта. Как в этом решении сделать вычитку из него и парсинг ролей/груп? Или даже так, раз мы собрались этот фукционал перенести в МУП, – как вызвать МУП чтобы проверить есть ли доступ к ресурсу?
Оценка трудозатрат тоже немаловажна в принятии решения. Как оцениваешь реализацию, какие этапы видишь?

---
 

По предложению https://confluence.ca.sbrf.ru/pages/viewpage.action?pageId=2605449852

Выписал плюсы и минусы и добавил функциональную схему

Плюсы и минусы предлагаемого подхода

+ реализуемость на разных компонентах
+ упрощается разработка приложений и появляется возможность использования разных языков программирования для создания приложений
+ упрощается тестирование (у используемых компонент простая логика, а вся система прав сводится в таблицу)
+ высокая скорость проверки прав
+ изменение схемы прав без доработок ПО
+ возможность в выдачи прав на время
+ всегда возможна замена на новые актуальные компоненты по отдельности
+ интеграция без доработок с разными ранее написанными системами
+ подходит для ограничения доступа к простому и статическому содержимому сайтов
+ полная интеграция для протоколов типа REST (передающих информацию о ресурсе и действии с ним в HTTP-заголовках)
+ небольшой размер ключа

- частичная интеграция для протоколов SOAP, gRPC (передающих информацию о ресурсе и действии в теле сообщения)
- при большом количестве клиентов и ресурсов количество записей в кэше может быть большим


Примеры
 

Так выглядят команды для ОС linux (Red Had, CentOS, Oracle Linux)

* При первоначальной установке
```
yum install -y memcached nginx
systemctl enable memcached nginx
systemctl start memcached nginx
```
* При перенастройке без остановки обслуживания клиентов
```
cp ./443.conf /etc/nginx/conf.d/443.conf
nginx -s reload
```
